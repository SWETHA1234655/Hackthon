//Baseclass

Package Declaration: package factory; - This line declares the package name for the class, which helps organize the code into different namespaces.
Imports: The code imports various classes needed for file reading, exception handling, URL processing, Selenium WebDriver, and logging functionalities.
Class Declaration: public class BaseClass - This is the declaration of the class named BaseClass.
Static Variables:
static WebDriver driver; - A static instance of WebDriver which will be used to control the browser.
static Properties p; - A static instance of Properties to load and access property values from a configuration file.
static Logger logger; - A static instance of Logger to log messages for debugging and information purposes.
Method initilizeBrowser(): This method initializes the WebDriver based on the execution environment (local or remote) and browser preference specified in a properties file.
Remote Execution: If the execution environment is set to “remote”, it sets up DesiredCapabilities based on the OS and browser specified in the properties file and initializes a RemoteWebDriver.
Local Execution: If the execution environment is “local”, it initializes either a ChromeDriver or EdgeDriver based on the browser specified.
Browser Setup: It configures the browser by deleting all cookies and setting implicit wait times.
Method getDriver(): Returns the instance of the WebDriver.
Method getProperties(): Loads the properties file located at \\src\\test\\resources\\config.properties relative to the user directory, and returns the Properties object.
Method getLogger(): Initializes and returns the Logger instance using Log4j for logging.
The code is structured to support both local and remote execution of Selenium WebDriver tests, allowing for flexibility in test environments. It also includes basic browser setup and logging capabilities. However, there are a few points to note:

The method name initilizeBrowser seems to be a typo; it should be initializeBrowser.
The commented-out line // driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(25)); suggests there might be an intention to set a page load timeout, but it’s currently inactive.
The comment //create the excel file is present, but there’s no code shown for creating an Excel file, which might be handled elsewhere in the WriteExcel utility class.
This setup is typical for a Selenium-based test automation framework that aims to provide a base for launching and managing browser instances for testing web applications.

//BasePage:
-----------
Constructor: public BasePage(WebDriver driver) - The constructor of the BasePage class takes a WebDriver object as a parameter.
this.driver=driver; - This line assigns the passed WebDriver instance to the class member variable driver. The this keyword is used to refer to the current object’s driver variable.
PageFactory.initElements(driver,this); - This line initializes the elements of the BasePage class with the driver instance. The PageFactory class provides the initElements method to initialize all WebElement fields annotated with FindBy, FindBys, or FindAll annotations.
The BasePage class serves as a base class for all page object classes. It ensures that the WebDriver instance is passed to each page object and that the web elements are initialized. This is part of the Page Object Model (POM) design pattern, which is widely used in Selenium for making the code more maintainable, reusable, and readable.


WebDriver: This is an interface from Selenium that represents an idealized web browser. The WebDriver is used to perform actions like opening a page, clicking on elements, and reading text.
PageFactory: This is a class provided by Selenium that supports the Page Object design pattern. It is used to initialize elements of a page class without having to define explicit findElement or findElements.
public class BasePage: This defines the BasePage as a public class that other classes can inherit from. It serves as a foundation for all other page objects in your test framework.
WebDriver driver;: This is a declaration of a WebDriver instance variable named driver. It will be used to interact with the web browser.
public BasePage(WebDriver driver): This is a constructor for the BasePage class. It takes a WebDriver object as a parameter.
this.driver=driver;: Inside the constructor, the driver parameter is assigned to the instance variable driver. This means that when a new BasePage object is created, it will use the provided WebDriver to perform actions.
PageFactory.initElements(driver, this);: This is a method call to initElements from the PageFactory class. It initializes the elements of the current class (this) with the provided driver. This is where the magic of PageFactory happens; it takes care of locating the elements when they are used, based on the annotations provided in the page class.
In summary, the BasePage class is designed to be extended by other page classes in your Selenium tests. It encapsulates the WebDriver instance and uses the PageFactory to initialize web elements. This setup promotes reusability and reduces boilerplate code in your page objects.

//Page object class
--------------------
Class Declaration: public class CI_001_CarHomePage extends BasePage - This declares a public class named CI_001_CarHomePage that inherits from BasePage. The naming convention suggests this class is for the first test case (CI_001) related to the Car Home Page.
Constructor: public CI_001_CarHomePage(WebDriver driver) - The constructor accepts a WebDriver object and passes it to the BasePage class’s constructor. This ensures that the WebDriver instance is initialized for this page object.
WebDriverWait Declaration: WebDriverWait wait=new WebDriverWait(driver,Duration.ofSeconds(10)); - A WebDriverWait object is created with a timeout of 10 seconds. This will be used to wait for certain conditions to be met before proceeding.
JavascriptExecutor Declaration: JavascriptExecutor js=(JavascriptExecutor)driver; - A JavascriptExecutor is declared, which allows you to execute JavaScript commands within the context of the browser through the WebDriver.
Locators:
@FindBy(xpath="(//div[@class='prd-icon add shadowHandler short']//div/i)[4]") WebElement carInsurance; - This uses the FindBy annotation to locate the car insurance element on the page using an XPath expression.
@FindBy(xpath="//span[@class='CarRegDetails_blueTextButton__P1blP blueTextButton fontMedium']") WebElement clickNewCar; - Another FindBy annotation to locate the “New Car” button element.
Actions:
public void clickCarInsurance() - This method waits until the carInsurance element is visible on the page and then uses the JavascriptExecutor to click on it.
public void clickNewBrandCar() throws InterruptedException - This method pauses the thread for 3 seconds (not recommended due to potential performance issues), waits until the clickNewCar element is visible, and then performs a click action on it.
The class CI_001_CarHomePage represents the car home page’s interface in the test framework, encapsulating the elements and actions that can be performed on that page. It uses explicit waits to ensure elements are ready before interactions and leverages JavaScript execution for clicking, which can be useful when standard click actions are not effective.

//Step definition
-----------------
Class Declaration: public class CarInsurance - This declares a public class named CarInsurance which contains the step definitions for the Cucumber scenarios.
Cucumber Annotations and Methods:
@Given("Navigate to Car insurance page") - This annotation links the text within quotes to a Gherkin step in a feature file. The method navigateToCarInsurancePage() is executed when this step is encountered.
Inside the method, it logs the action, initializes the CI_001_CarHomePage object, waits for 3 seconds, and then clicks on the car insurance option.
@When and @Then annotations work similarly, linking text to Gherkin steps and defining methods that are executed for those steps.
Actions Defined in Methods:
proceedWithoutCarNumber() - Proceeds with the scenario without providing a car number.
selectCityAndRTO() - Selects a city and RTO (Regional Transport Office) number.
selectCarBrand(), selectCarModel(), and selectCarVarient() - Selects the car brand, model, and variant respectively.
verifyuserDetailsIsDisplayed() - Verifies that the user details page is displayed.
fillInvalidUserDetails() - Fills in user details with an invalid phone number or email and asserts the result.
printTheErrorMessage() - Prints the error message received when invalid details are provided and writes it to an Excel file using the WriteExcel utility.
Assertions:
The code uses JUnit’s Assert class to verify expected conditions, such as whether the user details page is displayed or whether an error message matches the expected text.
Exception Handling:
The methods throw InterruptedException to handle any interruptions during the thread’s sleep period.
The fillInvalidUserDetails() method includes a try-catch block to handle exceptions and assert accordingly.
Logging:
The BaseClass.getLogger().info() calls log information about the current step being executed, which is helpful for debugging and understanding the flow of the test execution.
This class is part of a larger test framework that uses Cucumber for BDD testing, allowing non-technical stakeholders to understand the test scenarios while providing a clear mapping to the actual test code that is executed. The steps defined here would correspond to a feature file with Gherkin syntax describing the car insurance scenario.

TestRunner
-------------

JUnit Runner Declaration: @RunWith(Cucumber.class) - This annotation tells JUnit to run the class with the Cucumber test runner.
Cucumber Options Configuration: @CucumberOptions(...) - This annotation is used to configure various aspects of the Cucumber test runner:
features= {".//featureFiles"} - Specifies the path to the directory where the Cucumber feature files are located.
glue="stepDefinition" - Points to the package where the step definition classes are located.
plugin - Defines a list of plugins for generating reports in different formats:
"pretty" - Prints out the test results in a readable format.
"html:reports/myreport.html" - Generates an HTML report and saves it to the specified path.
"rerun:target/rerun.txt" - Creates a text file with a list of scenarios that failed and can be rerun.
"com.aventstack.extentreports.cucumber.adapter.ExtentCucumberAdapter:" - Integrates with ExtentReports for advanced reporting capabilities.
dryRun=false - When set to true, it checks if all the steps in the feature files have corresponding step definitions without actually running the tests. Here it’s set to false, meaning the tests will be executed.
monochrome=true - Enables more readable console output by removing unnecessary characters.
publish=true - When set to true, Cucumber will publish the test report to its online server for sharing.
Class Declaration: public class TestRunner - Declares the public class TestRunner, which doesn’t contain any methods. Its purpose is to serve as an entry point for running the Cucumber tests with the specified options.
This class is essential for executing the Cucumber BDD tests, as it ties together the feature files and step definitions and provides configuration for the test execution and reporting. The comments within the code provide additional context and explanations for each part of the configuration.

DATA READER:
------------------
Class Declaration: public class DataReader - This declares a public class named DataReader.
Static Variables:
public static String Name; - A static variable to store the name read from the Excel file.
public static String E_Mail; - A static variable to store the email address read from the Excel file.
public static String Phone_No; - A static variable to store the phone number read from the Excel file.
static XSSFCell f_name; - A static variable to reference the cell containing the name.
static XSSFCell mail; - A static variable to reference the cell containing the email address.
static XSSFCell phone; - A static variable to reference the cell containing the phone number.
Method ExcelData(): This static method is responsible for reading data from an Excel file.
FileInputStream fs=new FileInputStream("C:\\Users\\2318570\\eclipse-workspace\\Hackthon\\testData\\ReadDataFile.xlsx"); - Creates a FileInputStream to read data from the specified Excel file path.
XSSFWorkbook workbook=new XSSFWorkbook(fs); - Creates an instance of XSSFWorkbook by passing the file stream, which represents the entire Excel workbook.
XSSFSheet sheet=workbook.getSheetAt(0); - Gets the first sheet of the workbook.
XSSFRow row=sheet.getRow(1); - Retrieves the second row of the sheet (index 1, as it’s zero-based).
Name=row.getCell(0).toString(); - Reads the data from the first cell of the row as a string and assigns it to the Name variable.
E_Mail=row.getCell(1).toString(); - Reads the data from the second cell as a string and assigns it to the E_Mail variable.
Phone_No=row.getCell(2).toString(); - Reads the data from the third cell as a string and assigns it to the Phone_No variable.
Exception Handling:
The method is enclosed in a try-catch block to handle any exceptions that might occur during the file reading process. If an exception occurs, it prints the exception message to the console.
This class is typically used in automated testing frameworks to read test data from an Excel file, which can then be used to input data into web forms or verify information on a web page. The static nature of the variables and method allows them to be accessed without creating an instance of the DataReader class. However, it’s important to note that using static for test data is not always the best practice, as it can lead to issues with test isolation and parallel execution. Additionally, the code does not close the FileInputStream or the XSSFWorkbook, which could lead to resource leaks. It’s recommended to close these resources in a finally block or use a try-with-resources statement to ensure they are closed automatically.

WriteExcel
------------

Method: setCellData
This method writes data to a specific cell in an Excel sheet.

Parameters: It takes four parameters:
xlsheet: The name of the Excel sheet.
rownum: The row number where the data will be written.
colnum: The column number where the data will be written.
data: The data to write in the cell.
Process:
It first constructs the path to the Excel file (outputfile.xlsx) located in the testData directory within the user’s current working directory.
Opens a FileInputStream to read from the Excel file.
Creates an XSSFWorkbook object to interact with the workbook.
Retrieves the specified sheet from the workbook.
Checks if the specified row exists, and creates it if it doesn’t.
Creates a cell at the specified column in the row and sets its value to the provided data.
Opens a FileOutputStream to write the changes back to the Excel file.
Writes the workbook to the output stream.
Closes all resources to prevent memory leaks.
Method: createExcel
This method creates a new Excel file with predefined sheets and headers.

Process:
Defines the path to the new Excel file (outputfile.xlsx) in the testData directory.
Creates a FileOutputStream to write to the Excel file.
Initializes a new XSSFWorkbook to create a workbook.
Creates three sheets named “Health Insurance”, “Car Insurance”, and “Travel Insurance”.
Sets up a bold font style to be used for headers.
Creates the first row in each sheet and sets up headers with the bold font style:
“HC_MenuLists” in the “Health Insurance” sheet.
“Error_Msg” in the “Car Insurance” sheet.
“Plan” and “Price” in the “Travel Insurance” sheet.
Writes the workbook to the file output stream.
Closes the workbook and the file output stream.
The class provides functionality to both create a new Excel file with specific sheets and headers and to write data to an existing Excel file. It’s a utility class commonly used in test automation frameworks for data-driven testing, where test data is read from or written to Excel files. The use of static methods and variables allows these methods to be called without instantiating the WriteExcel class. However, it’s important to handle exceptions and close resources properly to avoid memory leaks, which the class attempts to do by closing streams after operations are completed.
